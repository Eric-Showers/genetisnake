<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Snakes!</title>
    <script src="https://code.jquery.com/jquery-3.1.1.js"></script>
    <script src="libs/three.js"></script>
    <script src="libs/TrackballControls.js"></script>
    <script src="libs/stats.js"></script>
    <script src="libs/dat.gui.js"></script>
    <script src="libs/jquery-1.12.4.js"></script>
    <script src="libs/jquery.splitter-0.14.0.js"></script>
    <link href="libs/jquery.splitter.css" rel="stylesheet"/>
    <script src="libs/datatables.js"></script>
    <link href="libs/datatables.css" rel="stylesheet"/>
    <style>
     body {
	 margin: 0;
         overflow: hidden;
     }
     
     #main_pane {
	 width: 100%;
	 height: 100%;
	 border: 2px solid blue;
     }

     #scene_pane {
	 border: 2px solid green;
         overflow: hidden;
     }

     #right_inner {
	 margin-right: 10px;
	 margin-left: 10px;
     }
     
     #right_pane {
	 border: 2px solid yellow;
     }

    </style>
  </head>
  
  <body>
    <div id="main_pane">
      <div id="scene_pane"></div>
      <div id="right_pane">
	<div id="right_inner">
	  <h1>Snakes!</h1>
	  <img src="training/turns.svg"/>
	  <table id="games_table" class="display" cellspacing="0" width="100%" height="100%"></table>
	</div>
      </div>
    </div>
    
    <script>
     var game;

     var renderer;
     var camera;
     var scene;
     
     function init() {
	 
	 var controls = new function() {
	     this.pointLightIntensity = .6;
	 }

	 var gui = new dat.GUI();
	 gui.add(controls, 'pointLightIntensity', 0, 3).onChange(function(e) {
	     pointLight.intensity = e;
	 });

         var clock = new THREE.Clock();
	 var scene = new THREE.Scene();

	 renderer = new THREE.WebGLRenderer();
	 renderer.setClearColor(0xEEEEEE, 1.0);
	 renderer.setSize(window.innerWidth, window.innerHeight);
	 renderer.shadowMap.Enabled = true;
	 
	 camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
         camera.position.set(0, 0, 30);
         camera.lookAt(scene.position);

         var trackballControls = new THREE.TrackballControls(camera);
         trackballControls.rotateSpeed = 1.0;
         trackballControls.zoomSpeed = 1.0;
         trackballControls.panSpeed = 1.0;
         trackballControls.staticMoving = true;
	 
	 var spotLight = new THREE.SpotLight(0xffffff);
	 spotLight.position.set(-20, 30, 10);
	 spotLight.castShadow = true;
	 scene.add(spotLight);
	 
	 var pointLight = new THREE.PointLight(0xccffcc);
	 pointLight.position.set(-5, 5, 20);
	 pointLight.intensity = controls.pointLightIntensity;
	 scene.add(pointLight);
	 // debug
	 //var pointLightAxes = new THREE.AxisHelper(10);
	 //pointLight.add(pointLightAxes);
	 
	 var BOARD_WIDTH = 20;
	 var BOARD_HEIGHT = 20;	 

	 var board_geometry = new THREE.PlaneBufferGeometry(BOARD_WIDTH, BOARD_HEIGHT, 32);
	 var board_material = new THREE.MeshLambertMaterial({color: 0xcccccc});
	 var board = new THREE.Mesh(board_geometry, board_material);
	 board.receiveShadow = true;
	 scene.add(board);
	 // debug
	 //var boardAxes = new THREE.AxisHelper(10);
	 //board.add(boardAxes);

	 
	 function SnakeCurve(body_pts) {
	     this.body_pts = body_pts;
	 }
	 SnakeCurve.prototype = Object.create(THREE.Curve.prototype);
	 SnakeCurve.prototype.constructor = SnakeCurve;
	 SnakeCurve.prototype.getPoint = function(t) {
	     var ti = t * (this.body_pts.length-1);
	     var i0 = Math.floor(ti);
	     if(i0 >= this.body_pts.length-1) {
		 i0 = this.body_pts.length-2;
	     }
	     var i1 = i0 + 1;
	     var dt = ti - i0;
	     var pt = this.body_pts[i0].clone().lerp(this.body_pts[i1], dt);
	     return pt;
	 }

	 var snake_group = new THREE.Group();
	 board.add(snake_group);

	 // render all snakes on the board
	 function game_render(game) {
	     // remove old snakes
	     for (var i = snake_group.children.length - 1; i >= 0; i--) {
		 snake_group.remove(snake_group.children[i]);
	     }
	     
	     // the center point of a board cell
	     function board_point(cell_x, cell_y, pt_z) {
		 var pt_x = (cell_x + 0.5) * BOARD_WIDTH / game.width - BOARD_WIDTH / 2;
		 var pt_y = BOARD_HEIGHT / 2 - (cell_y + 0.5) * BOARD_HEIGHT / game.height;
		 return new THREE.Vector3(pt_x, pt_y, pt_z);
	     }

	     var snake_body_width = BOARD_WIDTH / game.width / 2 * .9;
	     
	     // food!
	     var food_geometry = new THREE.SphereBufferGeometry(snake_body_width, 8, 8);
	     var food_material = new THREE.MeshLambertMaterial({color: 0xffff00});
	     for(var food_i=0; food_i<game.food.length; food_i++) {
		 var food = game.food[food_i];
		 var food_mesh = new THREE.Mesh(food_geometry, food_material);
		 food_mesh.position.copy(board_point(food[0], food[1], snake_body_width));
		 snake_group.add(food_mesh);
	     }

	     // extrude each snake
	     for(var snake_i=0; snake_i<game.snakes.length; snake_i++) {
		 var snake = game.snakes[snake_i];
		 // body path
		 if( snake.body.length > 1 ) {
		     var body_points = [];
		     for(var body_i=0; body_i<snake.body.length; body_i++) {
			 var body = game.snakes[snake_i].body;
			 body_points.push(board_point(body[body_i][0], body[body_i][1], snake_body_width));
		     }
		     var body_geometry = new THREE.TubeGeometry(new SnakeCurve(body_points), 5*snake.body.length, snake_body_width, 8, false);
		     //body_geometry.computeVertexNormals();
		     var body_material = new THREE.MeshLambertMaterial({ color: 0xff8000, wireframe: false, side: THREE.DoubleSide});
		     var snake_mesh = new THREE.Mesh(body_geometry, body_material);
		     snake_group.add(snake_mesh);
		 }
	     }
	 }

	 var GAME_FPS = 20;
	 var game_list_index = -1;
	 var game_dirty = false;
	 var game_turn_index = -1;
	 var game_turn_data;

	 function load_games_table(games) {
	     var rowData = [];
	     for(var i=0; i<games.length; i++) {
		 var row = [
		     games[i].turns,
		     games[i].generation,
		     games[i].game,
		     "",
		 ];
 		 rowData.push(row)
	     }
	     
	     var table;
	     table = $('#games_table').DataTable({
		 select:         true,
		 scrollY:        "800px",
		 scrollX:        true,
		 scrollCollapse: true,
		 paging:         false,
		 searching:      false,
		 order:          [[ 0, "desc" ]],
		 data:           games,
		 columns: [
		     { title: "Turns",      data: "turns", className: "dt-body-right" },
		     { title: "Generation", data: "generation", className: "dt-body-right" },
		     { title: "Game",       data: "game", className: "dt-body-right" },
		     { title: "Func Size",  data: "func_size", className: "dt-body-right" }
		 ],
		 fnInitComplete: function(oSettings, json) {
		     setTimeout(function() {
			 table.row(':eq(0)', { page: 'current' }).select();
			 //$('#games_table tbody tr:eq(0)').select();
			 }, 100);
		 }
	     });
	     table.on('select', function(e, dt, type, indexes) {
		 if( type == 'row' ) {
		     var path = table.rows(indexes).data().pluck('path')[0];
		     load_game("training/" + path);
		 }
	     } );
	 }
	 
	 function load_games_list(url) {
	     // load the game.  When loaded, set game_dirty
	     $.getJSON(url, function(data) {
		 // load games into table
		 load_games_table(data);
	     });
	 }
	 load_games_list("training/games.json");
	 
	 function load_game(url) {
	     // load the game.  When loaded, set game_dirty
	     $.getJSON(url, function(data) {
		 game_data = data;
		 game_turn_data = data["turns"];
		 game_turn_index = 0;
		 game_dirty = true;
	     });
	 }
	 
	 function game_update_timer() {
	     // after rendering, set the timer to render the next frame
	     game_turn_index += 1;
	     if( game_turn_index >= game_turn_data.length ) {
		 // TODO - load next game
		 game_turn_index = 0;
	     }
	     game = game_turn_data[game_turn_index];
	     game_dirty = true;
	 }

	 function render() {
             var delta = clock.getDelta();
             trackballControls.update(delta);

	     if( game_dirty ) {
		 game_render(game_turn_data[game_turn_index]);
		 game_dirty = false;
		 setTimeout(game_update_timer, 1000 / GAME_FPS);
	     }

	     
             renderer.render(scene, camera);
             requestAnimationFrame(render);
         }
	 resize();
	 document.getElementById("scene_pane").appendChild(renderer.domElement);
	 render();
     }
     window.onload = init;

     function resize() {
	 var splitter = $('#main_pane').width(window.innerWidth).height(window.innerHeight).split({
	     orientation: 'vertical',
	     limit: 10,
	     position: '60%', // if there is no percentage it interpret it as pixels
	     onDrag: function(event) {
		 resize();
	     }
	 });

	 if( camera && renderer ) {
	     var scene_pane = $("#scene_pane");
	     var w = scene_pane.innerWidth();
	     var h = scene_pane.innerHeight();
             camera.aspect = w / h;
             camera.updateProjectionMatrix();
             renderer.setSize(w, h);
	 }
     }
     window.addEventListener('resize', resize, false);

     
    </script>
  </body>
</html>
